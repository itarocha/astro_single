<!DOCTYPE html>
<html lang="pt-br">
<head>
<meta charset="UTF-8">
<title>Mapa Astral - Canvas HTML5</title>
<style>
  body { background:#f4f4f4; font-family: Arial, sans-serif; }
  canvas { background:#fff; display:block; margin:20px auto; }
</style>
</head>
<body>

<canvas id="mapa" width="640" height="640"></canvas>

<script>

const canvas = document.getElementById("mapa");
const ctx = canvas.getContext("2d");

const BASE_STROKE_SIZE = 2.0;
const BASE_CONNECT_LINE_SIZE = 1.0;
const BASE_ASPECT_LINE_SIZE = 6.0;

const OUTER_CIRCLE_INITIAL = 0.98;
const CARDINAL_INDICATOR_CIRCLE_INITIAL = 0.93;
const OUTER_SIGN_CIRCLE_INITIAL = 0.89;
const OUTER_HOUSE_CIRCLE_INITIAL = 0.79;
const OUTER_ASPECT_CIRCLE_INITIAL = 0.44;
const CUSP_TEXT_CIRCLE_INITIAL = 0.76;
const SIGN_GLYPH_CIRCLE_INITIAL = 0.84;
const CEL_POINT_TEXT_CIRCLE_INITIAL = 0.64;
const OUTER_CONNECTION_CIRCLE_INITIAL = 0.48;
const DEGREES_CIRCLE_INITIAL = 0.775;
const DEGREES5_CIRCLE_INITIAL = 0.76;
const CEL_POINT_GLYPH_CIRCLE_INITIAL = 0.54;
const VSP_CIRCLE_INITIAL = 0.39;

const SIGN_GLYPH_SIZE_INITIAL = 28.0;
const CEL_POINT_GLYPH_SIZE_INITIAL = 24.0;
const CARDINAL_FONT_SIZE_INITIAL = 16.0;
const CEL_POINT_TEXT_EAST_OFFSET_INITIAL = 8.0;
const CEL_POINT_TEXT_WEST_OFFSET_INITIAL = -20.0;
const POSITION_TEXT_SIZE_INITIAL = 10.0;
const VSP_TEXT_SIZE_INITIAL = 15.0;
const GLYPH_X_OFFSET_INITIAL = 0.0;
const GLYPH_Y_OFFSET_INITIAL = 0.0;

const GridSize = canvas.width;
const SizeFactor = 1.0
const OuterCircle = OUTER_CIRCLE_INITIAL * GridSize
const OuterRadius = OuterCircle / 2

const OuterSignCircle = OUTER_SIGN_CIRCLE_INITIAL * GridSize;
const OuterSignRadius = OuterSignCircle / 2;

const OuterHouseCircle = OUTER_HOUSE_CIRCLE_INITIAL * GridSize;
const OuterHouseRadius = OuterHouseCircle / 2;

const OuterAspectCircle = OUTER_ASPECT_CIRCLE_INITIAL * GridSize;
const OuterAspectRadius = OuterAspectCircle / 2;

const SignGlyphCircle = SIGN_GLYPH_CIRCLE_INITIAL * GridSize;
const SignGlyphRadius = SignGlyphCircle / 2;

const CuspTextCircle = CUSP_TEXT_CIRCLE_INITIAL * GridSize;
const CuspTextRadius = CuspTextCircle / 2;

const CelPointGlyphCircle = CEL_POINT_GLYPH_CIRCLE_INITIAL * GridSize;
const CelPointGlyphRadius = CelPointGlyphCircle / 2;

const OuterConnectionCircle = OUTER_CONNECTION_CIRCLE_INITIAL * GridSize;
const OuterConnectionRadius = OuterConnectionCircle / 2;

const DegreesCircle = DEGREES_CIRCLE_INITIAL * GridSize;
const DegreesRadius = DegreesCircle / 2;

const Degrees5Circle = DEGREES5_CIRCLE_INITIAL * GridSize;
const Degrees5Radius = Degrees5Circle / 2;

const StrokeSize = BASE_STROKE_SIZE * SizeFactor;
const StrokeSizeDouble = StrokeSize * 2.0;
const ConnectLineSize = BASE_CONNECT_LINE_SIZE * SizeFactor;
const AspectLineSize = BASE_ASPECT_LINE_SIZE * SizeFactor;
const GlyphXOffset = GLYPH_X_OFFSET_INITIAL * GridSize;
const GlyphYOffset = GLYPH_Y_OFFSET_INITIAL * GridSize;
const SignGlyphSize = SIGN_GLYPH_SIZE_INITIAL * (GridSize / 700.0);
const CelPointGlyphSize = CEL_POINT_GLYPH_SIZE_INITIAL * (GridSize / 700.0);
const CardinalFontSize = CARDINAL_FONT_SIZE_INITIAL * (GridSize / 700.0);
const CelPointTextEastOffset = CEL_POINT_TEXT_EAST_OFFSET_INITIAL * SizeFactor;
const CelPointTextWestOffset = CEL_POINT_TEXT_WEST_OFFSET_INITIAL * SizeFactor;
const PositionTextSize = POSITION_TEXT_SIZE_INITIAL * (GridSize / 700.0);
const VspTextSize = VSP_TEXT_SIZE_INITIAL * (GridSize / 700.0);


const cx = GridSize / 2;
const cy = GridSize / 2;

const degToRad = (degrees) => {
    return Math.PI / 180 * degrees
}

const createPoint = (angle, hypothenusa) => {  
  const a = degToRad(angle);
  const x = cx - Math.sin(a) * hypothenusa;
  const y = cy - Math.cos(a) * hypothenusa;
  return {x, y};
}

const angleDiff = (a, b) => {
  let d = Math.abs(a - b) % 360;
  return d > 180 ? 360 - d : d;
}

const createGraphicPositionsInWheel = (longitudeAscendant) => {
  return BODIES.map(body => {
    let lon = body.lon;
    let angle = body.lon - longitudeAscendant + 90.0;
    if (angle < 0.0) angle += 360.0;
    if (angle >= 360.0) angle -= 360.0;
    const point = createPoint(angle, CelPointGlyphRadius);
    return {
      name: body.name, 
      glyph: body.glyph, 
      lon:lon, 
      mundane_pos: angle, 
      plot_pos: angle, 
      x: point.x, 
      y: point.y};
  });
}

const drawCircle = (r) => {
  ctx.beginPath();
  ctx.arc(cx, cy, r, 0, Math.PI*2);
  ctx.stroke();
}

const drawDegreeIndications = (longAscendant, _hypoStart, _hypoDegree, _hypo5Degree) => {
  const offsetAsc = 30.0 - longAscendant % 30.0;
  let angle = offsetAsc;
  for (let i = 0; i < 360; i++)
  {
      let actualHypo = (i % 5 == 0) ? _hypo5Degree : _hypoDegree;
      const point1 = createPoint(angle, actualHypo);
      const point2 = createPoint(angle, _hypoStart);
      ctx.beginPath();
      ctx.moveTo(point1.x, point1.y);
      ctx.lineTo(point2.x, point2.y);
      ctx.stroke();
      angle += 1.0;
      if (angle >= 360.0) angle -= 360.0;
  }
}

const drawSignSeparators = (longAscendant) => {
  let offsetAsc = 30.0 - longAscendant % 30.0;
  let hypothenusa1 = OuterHouseRadius;
  let hypothenusa2 = OuterSignRadius;
  for (let i = 0; i < 12; i++)
  {
      let angle = i * 30 + offsetAsc;
      if (angle < 0.0) angle += 360.0;
      if (angle >= 360.0) angle -= 360.0;

      angle += 90.0;
      const point1 = createPoint(angle, hypothenusa1);
      const point2 = createPoint(angle, hypothenusa2);
      ctx.beginPath();
      ctx.moveTo(point1.x, point1.y);
      ctx.lineTo(point2.x, point2.y);
      ctx.stroke();
  }
}

const drawSignGlyphs = (longAscendant) => {
  let offsetAsc = 30.0 - (longAscendant % 30.0);
  let hypothenusa = SignGlyphRadius;
  let fontSize = 20;
  let glyphs = [ "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "-", "=" ];

  let indexFirstGlyph = Math.floor((longAscendant / 30.0) + 1);

  ctx.font = "20pt EnigmaAstrologyBLA2";
  let glyphIndex = indexFirstGlyph;
  for (let i = 0; i < 12; i++)
  {
      if (glyphIndex > 11) glyphIndex = 0;
      let angle = i * 30 + offsetAsc + 90.0 + 15.0;
      if (angle < 0.0) angle += 360.0;
      if (angle >= 360.0) angle -= 360.0;
      const point1 = createPoint(angle, hypothenusa);
      ctx.beginPath();
      ctx.fillText(glyphs[glyphIndex], point1.x - fontSize / 3, point1.y + fontSize / 2);
      ctx.stroke();
      glyphIndex++;
  }
}

const createSortedListForWheel = (graphicPositions) => {
  minDistance = 6.0; // Distância mínima entre os planetas, em graus
  lista = graphicPositions.sort((a, b) => a.mundane_pos - b.mundane_pos); // Ordena por posição

  lastPos = null;
  for (let i = 0; i < lista.length; i++) {
    let pos = lista[i];
    if (lastPos != null)
    {
      let actDistance = pos.mundane_pos - lastPos.plot_pos;
      if (actDistance < minDistance)
        {
            pos.plot_pos += minDistance - actDistance;
        }
    }
    lastPos = pos;
  }

  /* TODO: Se o último planeta tiver sido deslocado, pode ser necessário verificar novamente o primeiro planeta para garantir que a distância mínima seja mantida entre eles. Isso pode ser feito em um loop até que nenhuma posição precise ser ajustada.
    // substitua graphPositions para lista, e faça a ordenação e ajustes nela. Depois, no final, normalize as posições para 0-360 graus.
  //  Check for circular overlap between last and first item
  if (graphPositions.Count > 1)
  {
      var firstPos = graphPositions[0];
      var lastPosItem = graphPositions[^1];

      // Calculate circular distance from last to first (wrapping around 360)
      double circularDistance = (firstPos.PlotPos + 360.0 - lastPosItem.PlotPos);
      if (circularDistance >= 360.0) circularDistance -= 360.0;

      if (circularDistance < minDistance)
      {
          // There's overlap - need to adjust. Do a backward pass to redistribute spacing.
          double deficit = minDistance - circularDistance;

          // Adjust positions backward, starting from the last item
          for (int i = graphPositions.Count - 1; i >= 0; i--)
          {
              graphPositions[i].PlotPos -= deficit;

              // Ensure we maintain minDistance with the previous item (or wrap to last)
              if (i > 0)
              {
                  double distToPrevious = graphPositions[i].PlotPos - graphPositions[i - 1].PlotPos;
                  if (distToPrevious < minDistance && deficit < 20.0)
                  {
                      // Need to push previous items back further

                    deficit += (minDistance - distToPrevious);
                  }
                  else
                  {
                      // We have enough space, can stop adjusting
                      break;
                  }
              }
          }
      }
  }

  // Normalize all positions to 0-360 range
  foreach (var pos in graphPositions)
  {
      while (pos.PlotPos >= 360.0) pos.PlotPos -= 360.0;
      while (pos.PlotPos < 0.0) pos.PlotPos += 360.0;
  }
  */

  return lista;
}

const createCelPointConnectLines = (graphicPositions) => {
    for (let i = 0; i < graphicPositions.length; i++)
    {
      pos = graphicPositions[i];
      const point1 = createPoint(pos.plot_pos, OuterConnectionRadius);
      const point2 = createPoint(pos.mundane_pos, OuterAspectRadius);

      ctx.beginPath();
      ctx.moveTo(point1.x, point1.y);
      ctx.lineTo(point2.x, point2.y);
      ctx.stroke();
    }
}

const drawPlanetsGlyphs = (graphicPositions) => {
    let hypothenusa = CelPointGlyphRadius;
    let fontSize = 18;

    ctx.font = "18pt EnigmaAstrologyBLA2";
    for (let i = 0; i <= 9; i++)
    {
        pos = graphicPositions[i];
        const point1 = createPoint(pos.plot_pos, hypothenusa);
        ctx.beginPath();
        ctx.fillText(pos.glyph, point1.x - fontSize / 3, point1.y + fontSize / 2);
        ctx.stroke();
    }
}

const drawCuspLines = (housePositions, longAscendant) => {
    for (let i = 0; i < housePositions.length; i++)
    {
        let angle = housePositions[i] - longAscendant + 90.0;
        if (angle < 0.0) angle += 360.0;
        if (angle >= 360.0) angle -= 360.0;

        let width = i % 3 == 0 ? StrokeSizeDouble : StrokeSize;
        const point1 = createPoint(angle, OuterAspectRadius);
        const point2 = createPoint(angle, OuterHouseRadius);
        ctx.beginPath();
        ctx.moveTo(point1.x, point1.y);
        ctx.lineTo(point2.x, point2.y);
        ctx.stroke();
      }
}

// ===============================
// DADOS 
// ===============================
const CUSPS = [
  82.7015,
  111.1341,
  141.3461,
  173.6226,
  205.7392,
  235.3617,
  262.7015,
  291.1341,
  321.3462,
  353.6226,
  25.7392,
  55.3617
];

// Ecliptic positions of the bodies (in degrees)
// Mundane pos?
const BODIES = [
  {name:"Sol", glyph:"a", lon:97.6626},
  {name:"Lua", glyph:"b", lon:307.4590},
  {name:"Mer", glyph:"c", lon:120.9334},
  {name:"Ven", glyph:"d", lon:80.1461},
  {name:"Mar", glyph:"f", lon:120.4182},
  {name:"Jup", glyph:"g", lon:272.8765},
  {name:"Sat", glyph:"h", lon:73.6547},
  {name:"Ura", glyph:"i", lon:194.2189},
  {name:"Net", glyph:"j", lon:243.0043},
  {name:"Plu", glyph:"k", lon:179.4214}
];

ctx.font = "12px Arial";

//drawCircle(OuterRadius);
drawCircle(OuterSignRadius);
drawCircle(OuterHouseRadius);
drawCircle(OuterAspectRadius);

drawDegreeIndications(CUSPS[0], OuterHouseRadius, DegreesRadius, Degrees5Radius);

drawSignSeparators(CUSPS[0])
drawSignGlyphs(CUSPS[0])

drawCuspLines(CUSPS, CUSPS[0])

listGraphicPositions = createGraphicPositionsInWheel(CUSPS[0])
listGraphicPositions = createSortedListForWheel(listGraphicPositions)
createCelPointConnectLines(listGraphicPositions)



listGraphicPositions.forEach(pos => {
  console.log(pos)
});

drawPlanetsGlyphs(listGraphicPositions)

</script>

</body>
</html>
